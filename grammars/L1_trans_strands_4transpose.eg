;; A grammar to predict consensus gene structure based on several sources of evidence
;; To see how the macros expand, type the following:
;;  echo | xrate -g dart/grammars/geneStructure.eg -x expanded.eg
;;  less expanded.eg

;; Here begins the grammar.  
(grammar
 (name geneStructure)
 (parametric)

 ;; **** BEGIN PARAMETER DEFINITIONS  ****
 
 ;; Define a seed rate to initialize the training of rate parameters
 ;; Supposedly, setting this at a low value works best, though EM is reasonably robust. 
 (&define SEED 0.001)
 (&define species_SEED 0.1)
 (&define observation_SEED 0.01)
 
 ;; Probability parameters - used for initial distributions and production rules. 
 ;; Note that each 'category' nonterminal has its own equilibrium distribution
 ;; These are currently set as uniform - one might set this a bit more 'skewed' towards
 ;; the type of token that a nonterminal is expected to emit. 
 (&foreach 
  category
  (E0_forward_section E0_forward_trans E1_forward_section E1_forward_trans E2_forward_section E2_forward_trans E0_reverse_section E0_reverse_trans E1_reverse_section E1_reverse_trans E2_reverse_section E2_reverse_trans I0_forward_section I0_forward_trans I1_forward_section I1_forward_trans I2_forward_section I2_forward_trans I0_reverse_section I0_reverse_trans I1_reverse_section I1_reverse_trans I2_reverse_section I2_reverse_trans X_section X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  (&foreach-token TOK 
   (&if
    (&or
	 (&and (&eq category X_section) (&eq TOK x))
	 (&and (&eq category X_trans) (&eq TOK y))
	 
     (&and (&eq category E0_forward_section) (&eq TOK e))
	 (&and (&eq category E0_forward_trans) (&eq TOK p))
	 (&and (&eq category E1_forward_section) (&eq TOK f))
	 (&and (&eq category E1_forward_trans) (&eq TOK q))
     (&and (&eq category E2_forward_section) (&eq TOK g))
	 (&and (&eq category E2_forward_trans) (&eq TOK r))
     (&and (&eq category I0_forward_section) (&eq TOK i))
	 (&and (&eq category I0_forward_trans) (&eq TOK u))
	 (&and (&eq category I1_forward_section) (&eq TOK j))
	 (&and (&eq category I1_forward_trans) (&eq TOK v))
     (&and (&eq category I2_forward_section) (&eq TOK k))
	 (&and (&eq category I2_forward_trans) (&eq TOK w))
	 
	 (&and (&eq category E0_reverse_section) (&eq TOK E))
	 (&and (&eq category E0_reverse_trans) (&eq TOK P))
	 (&and (&eq category E1_reverse_section) (&eq TOK F))
	 (&and (&eq category E1_reverse_trans) (&eq TOK Q))
     (&and (&eq category E2_reverse_section) (&eq TOK G))
	 (&and (&eq category E2_reverse_trans) (&eq TOK R))
     (&and (&eq category I0_reverse_section) (&eq TOK I))
	 (&and (&eq category I0_reverse_trans) (&eq TOK U))
	 (&and (&eq category I1_reverse_section) (&eq TOK J))
	 (&and (&eq category I1_reverse_trans) (&eq TOK V))
     (&and (&eq category I2_reverse_section) (&eq TOK K))
	 (&and (&eq category I2_reverse_trans) (&eq TOK W))
	 
	 (&and (&eq category S_forward) (&eq TOK s))
	 (&and (&eq category T_forward) (&eq TOK t))
	 (&and (&eq category A0_forward) (&eq TOK a))
	 (&and (&eq category A1_forward) (&eq TOK b))
	 (&and (&eq category A2_forward) (&eq TOK c))
	 (&and (&eq category D0_forward) (&eq TOK d))
	 (&and (&eq category D1_forward) (&eq TOK o))
	 (&and (&eq category D2_forward) (&eq TOK n))
	 
	 (&and (&eq category S_reverse) (&eq TOK S))
	 (&and (&eq category T_reverse) (&eq TOK T))
	 (&and (&eq category A0_reverse) (&eq TOK A))
	 (&and (&eq category A1_reverse) (&eq TOK B))
	 (&and (&eq category A2_reverse) (&eq TOK C))
	 (&and (&eq category D0_reverse) (&eq TOK D))
	 (&and (&eq category D1_reverse) (&eq TOK O))
	 (&and (&eq category D2_reverse) (&eq TOK N))
    )
    (const (((&cat p_ category _ TOK) 1 )))
    (const (((&cat p_ category _ TOK) 0 ))) ) 
   )
  )
  
  (pgroup
   ;; Initial distribution over categories as governed by the start -> category transitions
   ((&foreach category (E0_forward_section E0_forward_trans E1_forward_section E1_forward_trans E2_forward_section E2_forward_trans E0_reverse_section E0_reverse_trans E1_reverse_section E1_reverse_trans E2_reverse_section E2_reverse_trans I0_forward_section I0_forward_trans I1_forward_section I1_forward_trans I2_forward_section I2_forward_trans I0_reverse_section I0_reverse_trans I1_reverse_section I1_reverse_trans I2_reverse_section I2_reverse_trans X_section X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse) ((&cat START2 category) 1) ) )
  )
  
 (pgroup
    ;; Probabilities of going from / staying in a given category at the CONSENSUS (e.g. root) level
  ((E_section2E_section .25) (E_section2E_trans .25) (E2I0 .083) (E2I1 .083) (E2I2 .084) (E2X .25))
  ((I_section2I_section .34) (I2E .33) (I_section2I_trans .33))
  ((X_section2X_section .25) (X2E .5) (X_section2X_trans .25))
  
 )
  
 ;; Rate parameters - one set governs the inter-species changes and another the 'observation' 
 ;; These are (for now) shared among the different chains used by the {E,I,X}_cons nonterminals
 (&foreach 
  TYPE 
  (species)
  (&foreach 
   SRC
   (e f g i j k x)
   (&foreach 
    DEST
    (e f g i j k x)
    (&if 
     (&eq SRC DEST) 
     ()
     (rate ((&cat TYPE _section_ SRC _ DEST) (&cat SEED) ) ) )
    ) ;; end DEST
   ) ;; end SRC
  ) ;; end TYPE

 (&foreach
  TYPE
  (species)
  (&foreach
   SRC
   (p q r u v w s t a b c d o n y)
   (&foreach
    DEST
    (p q r u v w s t a b c d o n y)
    (&if
     (&eq SRC DEST)
     ()
     (rate ((&cat TYPE _transition_ SRC _ DEST) (&cat SEED) ) ) )
    ) ;; end DEST
   ) ;; end SRC
  ) ;; end TYPE
  
 (&foreach
  TYPE
  (species)
  (&foreach
   FORWARD
   (e f g i j k)
   (&foreach
    BACKWARD
    (e f g i j k)
     (rate ((&cat TYPE _swap_section_ FORWARD _ BACKWARD) (&cat SEED) ))
    ) ;; end BACKWARD
   ) ;; end FORWARD
  ) ;; end TYPE
  
  (&foreach
  TYPE
  (species)
  (&foreach
   FORWARD
   (p q r u v w s t a b c d o n)
   (&foreach
    BACKWARD
    (p q r u v w s t a b c d o n)
     (rate ((&cat TYPE _swap_transition_ FORWARD _ BACKWARD) (&cat SEED) ))
    ) ;; end BACKWARD
   ) ;; end FORWARD
  ) ;; end TYPE

 (&foreach-leaf
  TYPE
  (&foreach
   SRC
   (e f g i j k x)
   (&foreach
    DEST
    (e f g i j k x)
    (&if
     (&eq SRC DEST)
     ()
     (rate ((&cat TYPE _section_ SRC _ DEST) (&cat SEED) ) ) )
    ) ;; end DEST
   ) ;; end SRC
  ) ;; end TYPE

 (&foreach-leaf
  TYPE
  (&foreach
   SRC
   (p q r u v w s t a b c d o n y)
   (&foreach
    DEST
    (p q r u v w s t a b c d o n y)
    (&if
     (&eq SRC DEST)
     ()
     (rate ((&cat TYPE _transition_ SRC _ DEST) (&cat SEED) ) ) )
    ) ;; end DEST
   ) ;; end SRC
  ) ;; end TYPE
  
  (&foreach-leaf
  TYPE
  (&foreach
   FORWARD
   (e f g i j k x)
   (&foreach
    BACKWARD
    (e f g i j k x)
     (rate ((&cat TYPE _swap_section_ FORWARD _ BACKWARD) (&cat SEED) ))
    ) ;; end BACKWARD
   ) ;; end FORWARD
  ) ;; end TYPE
  
  (&foreach-leaf
  TYPE
  (&foreach
   FORWARD
   (p q r u v w s t a b c d o n)
   (&foreach
    BACKWARD
    (p q r u v w s t a b c d o n)
     (rate ((&cat TYPE _swap_transition_ FORWARD _ BACKWARD) (&cat SEED) ))
    ) ;; end BACKWARD
   ) ;; end FORWARD
  ) ;; end TYPE

 ;; **** END PARAMETER DEFINITIONS  ****

 ;; **** BEGIN MARKOV CHAIN DEFINITIONS  ****

 ;; Define species_chain and observation_chain
 ;; These are identical in form, but they have separate parametrizations
 (&foreach 
  category 
  (E0_forward_section E1_forward_section E2_forward_section E0_reverse_section E1_reverse_section E2_reverse_section I0_forward_section I1_forward_section I2_forward_section I0_reverse_section I1_reverse_section I2_reverse_section X_section)
  (&foreach
   TYPE
   (species)
   ;; Define the Markov chains for residue substitution ( i - e - x )
   ;; There are two of these for each category - one for species-level evo and one observations
   (chain
    (update-policy parametric)
    (terminal ((&cat category _ TYPE)))
    
    ;; Initial probability distributions - call forth the parameters declared in the pgroup block above
    (&foreach-token
     TOK
     (initial (state (TOK)) (prob (&cat p_ category _ TOK)))
     )
    
    ;; Mutation rates - simply call forth the parameters declared in the rate blocks above
	 (&foreach
     SRC
	 (x)
     (&foreach
      DEST
	  (e f g i j k)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _section_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (DEST)) (to (SRC)) (rate (&cat TYPE _section_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (SRC)) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _section_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord DEST) 32) ) ) ) (to ( SRC ) ) (rate (&cat TYPE _section_ DEST _ SRC) ) )
	   )
      )
     )
	 
	 (&foreach
     SRC
	 (e f g i j k)
     (&foreach
      DEST
	  (e f g i j k)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _section_ SRC _ DEST) ) )
       )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord SRC) 32) ) ) ) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _section_ SRC _ DEST) ) )
       )
      )
     )
	 
	 (&foreach
     FORWARD
	 (e f g i j k)
	  (mutate (from (FORWARD)) (to (E)) (rate (&cat TYPE _swap_section_ FORWARD _ e) ) )
	  (mutate (from (FORWARD)) (to (F)) (rate (&cat TYPE _swap_section_ FORWARD _ f) ) )
	  (mutate (from (FORWARD)) (to (G)) (rate (&cat TYPE _swap_section_ FORWARD _ g) ) )
	  (mutate (from (FORWARD)) (to (I)) (rate (&cat TYPE _swap_section_ FORWARD _ i) ) )
	  (mutate (from (FORWARD)) (to (J)) (rate (&cat TYPE _swap_section_ FORWARD _ j) ) )
	  (mutate (from (FORWARD)) (to (K)) (rate (&cat TYPE _swap_section_ FORWARD _ k) ) )
	 )
	 
	 (&foreach
     FORWARD
	 (e f g i j k)
	  (mutate (from (E)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ e _ FORWARD) ) )
	  (mutate (from (F)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ f _ FORWARD) ) )
	  (mutate (from (G)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ g _ FORWARD) ) )
	  (mutate (from (I)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ i _ FORWARD) ) )
	  (mutate (from (J)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ j _ FORWARD) ) )
	  (mutate (from (K)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ k _ FORWARD) ) )
	 )
	 
    ) ;; end chain
   ) ;; end types
  ) ;; end categories

 (&foreach 
  category 
  (E0_forward_trans E1_forward_trans E2_forward_trans E0_reverse_trans E1_reverse_trans E2_reverse_trans I0_forward_trans I1_forward_trans I2_forward_trans I0_reverse_trans I1_reverse_trans I2_reverse_trans X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  (&foreach
   TYPE
   (species)
   ;; Define the Markov chains for residue substitution ( i - e - x )
   ;; There are two of these for each category - one for species-level evo and one observations
   (chain
    (update-policy parametric)
    (terminal ((&cat category _ TYPE)))
    
    ;; Initial probability distributions - call forth the parameters declared in the pgroup block above
    (&foreach-token
     TOK
     (initial (state (TOK)) (prob (&cat p_ category _ TOK)))
     )
    
    ;; Mutation rates - simply call forth the parameters declared in the rate blocks above
	 (&foreach
     SRC
	 (y)
     (&foreach
      DEST
	  (p q r u v w s t a b c d o n)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (DEST)) (to (SRC)) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (SRC)) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord DEST) 32) ) ) ) (to ( SRC ) ) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
	   )
      )
     )
	 
	 (&foreach
     SRC
	 (p q r u v w s t a b c d o n)
     (&foreach
      DEST
	  (p q r u v w s t a b c d o n)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
       )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord SRC) 32) ) ) ) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
       )
      )
     )
	 
	 (&foreach
     FORWARD
	 (p q r u v w s t a b c d o n)
	  (mutate (from (FORWARD)) (to (P)) (rate (&cat TYPE _swap_transition_ FORWARD _ p) ) )
	  (mutate (from (FORWARD)) (to (Q)) (rate (&cat TYPE _swap_transition_ FORWARD _ q) ) )
	  (mutate (from (FORWARD)) (to (R)) (rate (&cat TYPE _swap_transition_ FORWARD _ r) ) )
	  (mutate (from (FORWARD)) (to (U)) (rate (&cat TYPE _swap_transition_ FORWARD _ u) ) )
	  (mutate (from (FORWARD)) (to (V)) (rate (&cat TYPE _swap_transition_ FORWARD _ v) ) )
	  (mutate (from (FORWARD)) (to (W)) (rate (&cat TYPE _swap_transition_ FORWARD _ w) ) )
	  (mutate (from (FORWARD)) (to (S)) (rate (&cat TYPE _swap_transition_ FORWARD _ s) ) )
	  (mutate (from (FORWARD)) (to (T)) (rate (&cat TYPE _swap_transition_ FORWARD _ t) ) )
	  (mutate (from (FORWARD)) (to (A)) (rate (&cat TYPE _swap_transition_ FORWARD _ a) ) )
	  (mutate (from (FORWARD)) (to (B)) (rate (&cat TYPE _swap_transition_ FORWARD _ b) ) )
	  (mutate (from (FORWARD)) (to (C)) (rate (&cat TYPE _swap_transition_ FORWARD _ c) ) )
	  (mutate (from (FORWARD)) (to (D)) (rate (&cat TYPE _swap_transition_ FORWARD _ d) ) )
	  (mutate (from (FORWARD)) (to (O)) (rate (&cat TYPE _swap_transition_ FORWARD _ o) ) )
	  (mutate (from (FORWARD)) (to (N)) (rate (&cat TYPE _swap_transition_ FORWARD _ n) ) )
	 )
	 
	 (&foreach
     FORWARD
	 (p q r u v w s t a b c d o n)
	  (mutate (from (P)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ p _ FORWARD) ) )
	  (mutate (from (Q)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ q _ FORWARD) ) )
	  (mutate (from (R)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ r _ FORWARD) ) )
	  (mutate (from (U)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ u _ FORWARD) ) )
	  (mutate (from (V)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ v _ FORWARD) ) )
	  (mutate (from (W)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ w _ FORWARD) ) )
	  (mutate (from (S)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ s _ FORWARD) ) )
	  (mutate (from (T)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ t _ FORWARD) ) )
	  (mutate (from (A)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ a _ FORWARD) ) )
	  (mutate (from (B)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ b _ FORWARD) ) )
	  (mutate (from (C)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ c _ FORWARD) ) )
	  (mutate (from (D)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ d _ FORWARD) ) )
	  (mutate (from (O)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ o _ FORWARD) ) )
	  (mutate (from (N)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ n _ FORWARD) ) )
	 )	 
    ) ;; end chain
   ) ;; end types
  ) ;; end categories


 ;; Define species_chain and observation_chain
 ;; These are identical in form, but they have separate parametrizations
 (&foreach 
  category 
  (E0_forward_section E1_forward_section E2_forward_section E0_reverse_section E1_reverse_section E2_reverse_section I0_forward_section I1_forward_section I2_forward_section I0_reverse_section I1_reverse_section I2_reverse_section X_section)
  (&foreach
   TYPE
   (species)
   ;; Define the Markov chains for residue substitution ( i - e - x )
   ;; There are two of these for each category - one for species-level evo and one observations
   (chain
    (update-policy parametric)
    (terminal ((&cat category _ backwards)))
    
    ;; Initial probability distributions - call forth the parameters declared in the pgroup block above
    (&foreach-token
     TOK
     (initial (state (TOK)) (prob (&cat p_ category _ TOK)))
     )
    
    ;; Mutation rates - simply call forth the parameters declared in the rate blocks above
	 (&foreach
     SRC
	 (x)
     (&foreach
      DEST
	  (e f g i j k)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _section_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (DEST)) (to (SRC)) (rate (&cat TYPE _section_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (SRC)) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _section_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord DEST) 32) ) ) ) (to ( SRC ) ) (rate (&cat TYPE _section_ SRC _ DEST) ) )
	   )
      )
     )
	 
	 (&foreach
     SRC
	 (e f g i j k)
     (&foreach
      DEST
	  (e f g i j k)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _section_ DEST _ SRC) ) )
       )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord SRC) 32) ) ) ) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _section_ DEST _ SRC) ) )
       )
      )
     )
	 
	 (&foreach
     FORWARD
	 (e f g i j k)
	  (mutate (from (FORWARD)) (to (E)) (rate (&cat TYPE _swap_section_ e _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (F)) (rate (&cat TYPE _swap_section_ f _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (G)) (rate (&cat TYPE _swap_section_ g _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (I)) (rate (&cat TYPE _swap_section_ i _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (J)) (rate (&cat TYPE _swap_section_ j _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (K)) (rate (&cat TYPE _swap_section_ k _ FORWARD) ) )
	 )
	 
	 (&foreach
     FORWARD
	 (e f g i j k)
	  (mutate (from (E)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ FORWARD _ e) ) )
	  (mutate (from (F)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ FORWARD _ f) ) )
	  (mutate (from (G)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ FORWARD _ g) ) )
	  (mutate (from (I)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ FORWARD _ i) ) )
	  (mutate (from (J)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ FORWARD _ j) ) )
	  (mutate (from (K)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ FORWARD _ k) ) )
	 )
	 
    ) ;; end chain
   ) ;; end types
  ) ;; end categories

 (&foreach 
  category 
  (E0_forward_trans E1_forward_trans E2_forward_trans E0_reverse_trans E1_reverse_trans E2_reverse_trans I0_forward_trans I1_forward_trans I2_forward_trans I0_reverse_trans I1_reverse_trans I2_reverse_trans X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  (&foreach
   TYPE
   (species)
   ;; Define the Markov chains for residue substitution ( i - e - x )
   ;; There are two of these for each category - one for species-level evo and one observations
   (chain
    (update-policy parametric)
    (terminal ((&cat category _ backwards)))
    
    ;; Initial probability distributions - call forth the parameters declared in the pgroup block above
    (&foreach-token
     TOK
     (initial (state (TOK)) (prob (&cat p_ category _ TOK)))
     )
    
    ;; Mutation rates - simply call forth the parameters declared in the rate blocks above
	 (&foreach
     SRC
	 (y)
     (&foreach
      DEST
	  (p q r u v w s t a b c d o n)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (DEST)) (to (SRC)) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (SRC)) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord DEST) 32) ) ) ) (to ( SRC ) ) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
	   )
      )
     )
	 
	 (&foreach
     SRC
	 (p q r u v w s t a b c d o n)
     (&foreach
      DEST
	  (p q r u v w s t a b c d o n)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
       )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord SRC) 32) ) ) ) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
       )
      )
     )
	 
	 (&foreach
     FORWARD
	 (p q r u v w s t a b c d o n)
	  (mutate (from (FORWARD)) (to (P)) (rate (&cat TYPE _swap_transition_ p _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (Q)) (rate (&cat TYPE _swap_transition_ q _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (R)) (rate (&cat TYPE _swap_transition_ r _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (U)) (rate (&cat TYPE _swap_transition_ u _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (V)) (rate (&cat TYPE _swap_transition_ v _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (W)) (rate (&cat TYPE _swap_transition_ w _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (S)) (rate (&cat TYPE _swap_transition_ s _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (T)) (rate (&cat TYPE _swap_transition_ t _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (A)) (rate (&cat TYPE _swap_transition_ a _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (B)) (rate (&cat TYPE _swap_transition_ b _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (C)) (rate (&cat TYPE _swap_transition_ c _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (D)) (rate (&cat TYPE _swap_transition_ d _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (O)) (rate (&cat TYPE _swap_transition_ o _ FORWARD) ) )
	  (mutate (from (FORWARD)) (to (N)) (rate (&cat TYPE _swap_transition_ n _ FORWARD) ) )
	 )
	 
	 (&foreach
     FORWARD
	 (p q r u v w s t a b c d o n)
	  (mutate (from (P)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ p) ) )
	  (mutate (from (Q)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ q) ) )
	  (mutate (from (R)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ r) ) )
	  (mutate (from (U)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ u) ) )
	  (mutate (from (V)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ v) ) )
	  (mutate (from (W)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ w) ) )
	  (mutate (from (S)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ s) ) )
	  (mutate (from (T)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ t) ) )
	  (mutate (from (A)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ a) ) )
	  (mutate (from (B)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ b) ) )
	  (mutate (from (C)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ c) ) )
	  (mutate (from (D)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ d) ) )
	  (mutate (from (O)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ o) ) )
	  (mutate (from (N)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ FORWARD _ n) ) )
	 )	 
    ) ;; end chain
   ) ;; end types
  ) ;; end categories



 (&foreach 
  category 
  (E0_forward_section E1_forward_section E2_forward_section E0_reverse_section E1_reverse_section E2_reverse_section I0_forward_section I1_forward_section I2_forward_section I0_reverse_section I1_reverse_section I2_reverse_section X_section)
  (&foreach-leaf
   TYPE
   ;; Define the Markov chains for residue substitution ( i - e - x )
   ;; There are two of these for each category - one for species-level evo and one observations
   (chain
    (update-policy parametric)
    (terminal ((&cat category _ TYPE)))
    
    ;; Initial probability distributions - call forth the parameters declared in the pgroup block above
    (&foreach-token
     TOK
     (initial (state (TOK)) (prob (&cat p_ category _ TOK)))
     )
    
    ;; Mutation rates - simply call forth the parameters declared in the rate blocks above
	 (&foreach
     SRC
	 (x)
     (&foreach
      DEST
	  (e f g i j k)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _section_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (DEST)) (to (SRC)) (rate (&cat TYPE _section_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (SRC)) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _section_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord DEST) 32) ) ) ) (to ( SRC ) ) (rate (&cat TYPE _section_ DEST _ SRC) ) )
	   )
      )
     )
	 
	 (&foreach
     SRC
	 (e f g i j k)
     (&foreach
      DEST
	  (e f g i j k)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _section_ SRC _ DEST) ) )
       )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord SRC) 32) ) ) ) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _section_ SRC _ DEST) ) )
       )
      )
     )
	 
	 (&foreach
     FORWARD
	 (e f g i j k)
	  (mutate (from (FORWARD)) (to (E)) (rate (&cat TYPE _swap_section_ FORWARD _ e) ) )
	  (mutate (from (FORWARD)) (to (F)) (rate (&cat TYPE _swap_section_ FORWARD _ f) ) )
	  (mutate (from (FORWARD)) (to (G)) (rate (&cat TYPE _swap_section_ FORWARD _ g) ) )
	  (mutate (from (FORWARD)) (to (I)) (rate (&cat TYPE _swap_section_ FORWARD _ i) ) )
	  (mutate (from (FORWARD)) (to (J)) (rate (&cat TYPE _swap_section_ FORWARD _ j) ) )
	  (mutate (from (FORWARD)) (to (K)) (rate (&cat TYPE _swap_section_ FORWARD _ k) ) )
	 )
	 
	 (&foreach
     FORWARD
	 (e f g i j k)
	  (mutate (from (E)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ e _ FORWARD) ) )
	  (mutate (from (F)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ f _ FORWARD) ) )
	  (mutate (from (G)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ g _ FORWARD) ) )
	  (mutate (from (I)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ i _ FORWARD) ) )
	  (mutate (from (J)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ j _ FORWARD) ) )
	  (mutate (from (K)) (to (FORWARD)) (rate (&cat TYPE _swap_section_ k _ FORWARD) ) )
	 )
	 
    ) ;; end chain
   ) ;; end types
  ) ;; end categories

 (&foreach 
  category 
  (E0_forward_trans E1_forward_trans E2_forward_trans E0_reverse_trans E1_reverse_trans E2_reverse_trans I0_forward_trans I1_forward_trans I2_forward_trans I0_reverse_trans I1_reverse_trans I2_reverse_trans X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  (&foreach-leaf
   TYPE
   ;; Define the Markov chains for residue substitution ( i - e - x )
   ;; There are two of these for each category - one for species-level evo and one observations
   (chain
    (update-policy parametric)
    (terminal ((&cat category _ TYPE)))
    
    ;; Initial probability distributions - call forth the parameters declared in the pgroup block above
    (&foreach-token
     TOK
     (initial (state (TOK)) (prob (&cat p_ category _ TOK)))
     )
    
    ;; Mutation rates - simply call forth the parameters declared in the rate blocks above
	 (&foreach
     SRC
	 (y)
     (&foreach
      DEST
	  (p q r u v w s t a b c d o n)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (DEST)) (to (SRC)) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from (SRC)) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
	   )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord DEST) 32) ) ) ) (to ( SRC ) ) (rate (&cat TYPE _transition_ DEST _ SRC) ) )
	   )
      )
     )
	 
	 (&foreach
     SRC
	 (p q r u v w s t a b c d o n)
     (&foreach
      DEST
	  (p q r u v w s t a b c d o n)
      (&if
       (&eq SRC DEST)
       ()
       (mutate (from (SRC)) (to (DEST)) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
       )
	  (&if
       (&eq SRC DEST)
       ()
	   (mutate (from ( (&chr (&sub (&ord SRC) 32) ) ) ) (to ( (&chr (&sub (&ord DEST) 32) ) ) ) (rate (&cat TYPE _transition_ SRC _ DEST) ) )
       )
      )
     )
	 
	 (&foreach
     FORWARD
	 (p q r u v w s t a b c d o n)
	  (mutate (from (FORWARD)) (to (P)) (rate (&cat TYPE _swap_transition_ FORWARD _ p) ) )
	  (mutate (from (FORWARD)) (to (Q)) (rate (&cat TYPE _swap_transition_ FORWARD _ q) ) )
	  (mutate (from (FORWARD)) (to (R)) (rate (&cat TYPE _swap_transition_ FORWARD _ r) ) )
	  (mutate (from (FORWARD)) (to (U)) (rate (&cat TYPE _swap_transition_ FORWARD _ u) ) )
	  (mutate (from (FORWARD)) (to (V)) (rate (&cat TYPE _swap_transition_ FORWARD _ v) ) )
	  (mutate (from (FORWARD)) (to (W)) (rate (&cat TYPE _swap_transition_ FORWARD _ w) ) )
	  (mutate (from (FORWARD)) (to (S)) (rate (&cat TYPE _swap_transition_ FORWARD _ s) ) )
	  (mutate (from (FORWARD)) (to (T)) (rate (&cat TYPE _swap_transition_ FORWARD _ t) ) )
	  (mutate (from (FORWARD)) (to (A)) (rate (&cat TYPE _swap_transition_ FORWARD _ a) ) )
	  (mutate (from (FORWARD)) (to (B)) (rate (&cat TYPE _swap_transition_ FORWARD _ b) ) )
	  (mutate (from (FORWARD)) (to (C)) (rate (&cat TYPE _swap_transition_ FORWARD _ c) ) )
	  (mutate (from (FORWARD)) (to (D)) (rate (&cat TYPE _swap_transition_ FORWARD _ d) ) )
	  (mutate (from (FORWARD)) (to (O)) (rate (&cat TYPE _swap_transition_ FORWARD _ o) ) )
	  (mutate (from (FORWARD)) (to (N)) (rate (&cat TYPE _swap_transition_ FORWARD _ n) ) )
	 )
	 
	 (&foreach
     FORWARD
	 (p q r u v w s t a b c d o n)
	  (mutate (from (P)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ p _ FORWARD) ) )
	  (mutate (from (Q)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ q _ FORWARD) ) )
	  (mutate (from (R)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ r _ FORWARD) ) )
	  (mutate (from (U)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ u _ FORWARD) ) )
	  (mutate (from (V)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ v _ FORWARD) ) )
	  (mutate (from (W)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ w _ FORWARD) ) )
	  (mutate (from (S)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ s _ FORWARD) ) )
	  (mutate (from (T)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ t _ FORWARD) ) )
	  (mutate (from (A)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ a _ FORWARD) ) )
	  (mutate (from (B)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ b _ FORWARD) ) )
	  (mutate (from (C)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ c _ FORWARD) ) )
	  (mutate (from (D)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ d _ FORWARD) ) )
	  (mutate (from (O)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ o _ FORWARD) ) )
	  (mutate (from (N)) (to (FORWARD)) (rate (&cat TYPE _swap_transition_ n _ FORWARD) ) )
	 )	 
    ) ;; end chain
   ) ;; end types
  ) ;; end categories
  
 ;; Done defining regular chains

 
 ;; Define the hybrid chains, which are composed of a category_species chain and a category_observation components
 ;; The observation chain models transitions on terminal branches (leading to "leaves") 
 ;; and the species chain models transitions on the internal branches. 
 ;; This declaration is a bit hairy, since we've got multiple loops *within* the components block.  See this page for details on hybrids:
 ;; http://biowiki.org/XrateFormat#Hybrid_chains
 (&foreach 
  category
  (E0_forward_section E0_forward_trans E1_forward_section E1_forward_trans E2_forward_section E2_forward_trans E0_reverse_section E0_reverse_trans E1_reverse_section E1_reverse_trans E2_reverse_section E2_reverse_trans I0_forward_section I0_forward_trans I1_forward_section I1_forward_trans I2_forward_section I2_forward_trans I0_reverse_section I0_reverse_trans I1_reverse_section I1_reverse_trans I2_reverse_section I2_reverse_trans X_section X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  (hybrid-chain
   (terminal ((&cat category _ -hybrid))) ;; Name the hybrid chain based on the category it emits from.
   (row ?) ;; We'd like the label (below) to correspond to a node name (again, see biowiki link above).
   (components ;; Define the components of the hybrid chain - this is based on whether or not the branch is *terminal*
    (&foreach-leaf
     NODE
     ((label NODE) (terminal ((&cat category _ NODE)))) ;; for branches leading to leaves - use the observation chain
     );; end leaf
    (&foreach-ancestor
     NODE
     ((label NODE) (terminal ((&cat category _ species)))) ;; for branches leading to ancestral nodes - use the species chain
     ) ;; end ancestor
    );; end components
   );; end hybrid chain
  );; end category
 ;; Done defining hybrid chains
 
 ;; **** END MARKOV CHAIN DEFINITIONS  ****

 ;; **** BEGIN TOP-LEVEL PRODUCTION RULES **** 

 ;; Transitions from start
 (&foreach 
  category
  (E0_forward_section E0_forward_trans E1_forward_section E1_forward_trans E2_forward_section E2_forward_trans E0_reverse_section E0_reverse_trans E1_reverse_section E1_reverse_trans E2_reverse_section E2_reverse_trans I0_forward_section I0_forward_trans I1_forward_section I1_forward_trans I2_forward_section I2_forward_trans I0_reverse_section I0_reverse_trans I1_reverse_section I1_reverse_trans I2_reverse_section I2_reverse_trans X_section X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  (transform  (from (START))  (to (category)) (prob (&cat START2 category)))
  )
  
 ;; START->END transition ensures that empty alignments don't have zero likelihood
 (transform (from (START))  (to ()))

 ;; Emit, end rules
 (&foreach
  SRC_category
  (E0_forward_section E0_forward_trans E1_forward_section E1_forward_trans E2_forward_section E2_forward_trans E0_reverse_section E0_reverse_trans E1_reverse_section E1_reverse_trans E2_reverse_section E2_reverse_trans I0_forward_section I0_forward_trans I1_forward_section I1_forward_trans I2_forward_section I2_forward_trans I0_reverse_section I0_reverse_trans I1_reverse_section I1_reverse_trans I2_reverse_section I2_reverse_trans X_section X_trans S_forward S_reverse T_forward T_reverse A0_forward A0_reverse A1_forward A1_reverse A2_forward A2_reverse D0_forward D0_reverse D1_forward D1_reverse D2_forward D2_reverse)
  ;; Each category nonterminal produces an alignment column, and then potentially ends the alignment
  ;; Each category nonterminal emits using its specially-designed hybrid chain.
  (transform  (from (SRC_category))  (to ((&cat SRC_category _ -hybrid) (&cat SRC_category *))))
  (transform  (from ((&cat SRC_category *)))  (to ()))
 )
 
 ;; Production rules for transitions between categories
 (transform (from (X_section*)) (to (X_trans)) (prob X_section2X_trans))
 (transform (from (X_trans*)) (to (X_section)))
 (transform (from (X_section*)) (to (X_section)) (prob X_section2X_section))
 (transform (from (X_section*)) (to (S_forward)) (prob X2E / 2))
 (transform (from (X_section*)) (to (T_reverse)) (prob X2E / 2))
 
 
 (transform (from (S_forward*)) (to (E0_forward_section)))
 (transform (from (A0_forward*)) (to (E0_forward_section)))
 (transform (from (E0_forward_section*)) (to (E0_forward_trans)) (prob E_section2E_trans))
 (transform (from (E0_forward_trans*)) (to (E0_forward_section)) (prob 1))
 (transform (from (E0_forward_section*)) (to (E0_forward_section)) (prob E_section2E_section))
 (transform (from (E0_forward_section*)) (to (D0_forward)) (prob E2I0))
 (transform (from (E0_forward_section*)) (to (D1_forward)) (prob E2I1))
 (transform (from (E0_forward_section*)) (to (D2_forward)) (prob E2I2))
 (transform (from (E0_forward_section*)) (to (T_forward)) (prob E2X))
 (transform (from (T_forward*)) (to (X_section)))
 
 (transform (from (A1_forward*)) (to (E1_forward_section)))
 (transform (from (E1_forward_section*)) (to (E1_forward_trans)) (prob E_section2E_trans))
 (transform (from (E1_forward_trans*)) (to (E1_forward_section)))
 (transform (from (E1_forward_section*)) (to (E1_forward_section)) (prob E_section2E_section))
 (transform (from (E1_forward_section*)) (to (D0_forward)) (prob E2I0))
 (transform (from (E1_forward_section*)) (to (D1_forward)) (prob E2I1))
 (transform (from (E1_forward_section*)) (to (D2_forward)) (prob E2I2))
 (transform (from (E1_forward_section*)) (to (T_forward)) (prob E2X))
 (transform (from (T_forward*)) (to (X_section)))
 
 (transform (from (A2_forward*)) (to (E2_forward_section)))
 (transform (from (E2_forward_section*)) (to (E2_forward_trans)) (prob E_section2E_trans))
 (transform (from (E2_forward_trans*)) (to (E2_forward_section)))
 (transform (from (E2_forward_section*)) (to (E2_forward_section)) (prob E_section2E_section))
 (transform (from (E2_forward_section*)) (to (D0_forward)) (prob E2I0))
 (transform (from (E2_forward_section*)) (to (D1_forward)) (prob E2I1))
 (transform (from (E2_forward_section*)) (to (D2_forward)) (prob E2I2))
 (transform (from (E2_forward_section*)) (to (T_forward)) (prob E2X))
 (transform (from (T_forward*)) (to (X_section)))
 
 (transform (from (D0_forward*)) (to (I0_forward_section)))
 (transform (from (I0_forward_section*)) (to (I0_forward_trans)) (prob I_section2I_trans))
 (transform (from (I0_forward_trans*)) (to (I0_forward_section)))
 (transform (from (I0_forward_section*)) (to (I0_forward_section)) (prob I_section2I_section))
 (transform (from (I0_forward_section*)) (to (A0_forward)) (prob I2E))
 
 (transform (from (D1_forward*)) (to (I1_forward_section)))
 (transform (from (I1_forward_section*)) (to (I1_forward_trans)) (prob I_section2I_trans))
 (transform (from (I1_forward_trans*)) (to (I1_forward_section)))
 (transform (from (I1_forward_section*)) (to (I1_forward_section)) (prob I_section2I_section))
 (transform (from (I1_forward_section*)) (to (A1_forward)) (prob I2E))
 
 (transform (from (D2_forward*)) (to (I2_forward_section)))
 (transform (from (I2_forward_section*)) (to (I2_forward_trans)) (prob I_section2I_trans))
 (transform (from (I2_forward_trans*)) (to (I2_forward_section)))
 (transform (from (I2_forward_section*)) (to (I2_forward_section)) (prob I_section2I_section))
 (transform (from (I2_forward_section*)) (to (A2_forward)) (prob I2E))
 

 (transform (from (T_reverse*)) (to (E0_reverse_section)))
 (transform (from (D0_reverse*)) (to (E0_reverse_section)))
 (transform (from (E0_reverse_section*)) (to (E0_reverse_trans)) (prob E_section2E_trans))
 (transform (from (E0_reverse_trans*)) (to (E0_reverse_section)) (prob 1))
 (transform (from (E0_reverse_section*)) (to (E0_reverse_section)) (prob E_section2E_section))
 (transform (from (E0_reverse_section*)) (to (A0_reverse)) (prob E2I0))
 (transform (from (E0_reverse_section*)) (to (A1_reverse)) (prob E2I1))
 (transform (from (E0_reverse_section*)) (to (A2_reverse)) (prob E2I2))
 (transform (from (E0_reverse_section*)) (to (S_reverse)) (prob E2X))
 
 (transform (from (D1_reverse*)) (to (E1_reverse_section)))
 (transform (from (E1_reverse_section*)) (to (E1_reverse_trans)) (prob E_section2E_trans))
 (transform (from (E1_reverse_trans*)) (to (E1_reverse_section)))
 (transform (from (E1_reverse_section*)) (to (E1_reverse_section)) (prob E_section2E_section))
 (transform (from (E1_reverse_section*)) (to (A0_reverse)) (prob E2I0))
 (transform (from (E1_reverse_section*)) (to (A1_reverse)) (prob E2I1))
 (transform (from (E1_reverse_section*)) (to (A2_reverse)) (prob E2I2))
 (transform (from (E1_reverse_section*)) (to (S_reverse)) (prob E2X))
 (transform (from (S_reverse*)) (to (X_section)))
 
 (transform (from (D2_reverse*)) (to (E2_reverse_section)))
 (transform (from (E2_reverse_section*)) (to (E2_reverse_trans)) (prob E_section2E_trans))
 (transform (from (E2_reverse_trans*)) (to (E2_reverse_section)))
 (transform (from (E2_reverse_section*)) (to (E2_reverse_section)) (prob E_section2E_section))
 (transform (from (E2_reverse_section*)) (to (A0_reverse)) (prob E2I0))
 (transform (from (E2_reverse_section*)) (to (A1_reverse)) (prob E2I1))
 (transform (from (E2_reverse_section*)) (to (A2_reverse)) (prob E2I2))
 (transform (from (E2_reverse_section*)) (to (S_reverse)) (prob E2X))
 (transform (from (S_reverse*)) (to (X_section)))
 
 (transform (from (A0_reverse*)) (to (I0_reverse_section)))
 (transform (from (I0_reverse_section*)) (to (I0_reverse_trans)) (prob I_section2I_trans))
 (transform (from (I0_reverse_trans*)) (to (I0_reverse_section)))
 (transform (from (I0_reverse_section*)) (to (I0_reverse_section)) (prob I_section2I_section))
 (transform (from (I0_reverse_section*)) (to (D0_reverse)) (prob I2E))
 
 (transform (from (A1_reverse*)) (to (I1_reverse_section)))
 (transform (from (I1_reverse_section*)) (to (I1_reverse_trans)) (prob I_section2I_trans))
 (transform (from (I1_reverse_trans*)) (to (I1_reverse_section)))
 (transform (from (I1_reverse_section*)) (to (I1_reverse_section)) (prob I_section2I_section))
 (transform (from (I1_reverse_section*)) (to (D1_reverse)) (prob I2E))
 
 (transform (from (A2_reverse*)) (to (I2_reverse_section)))
 (transform (from (I2_reverse_section*)) (to (I2_reverse_trans)) (prob I_section2I_trans))
 (transform (from (I2_reverse_trans*)) (to (I2_reverse_section)))
 (transform (from (I2_reverse_section*)) (to (I2_reverse_section)) (prob I_section2I_section))
 (transform (from (I2_reverse_section*)) (to (D2_reverse)) (prob I2E))

) ;; end grammar geneStructure

;; **** END TOP-LEVEL PRODUCTION RULES **** 

(alphabet
 (name geneStructure)
 (token (e f g i j k s t a b c d o n p q r u v w E F G I J K S T A B C D O N P Q R U V W x y))
 (extend (to X) (from x))
 (wildcard *)
 ) ;; end alphabet geneStructure

